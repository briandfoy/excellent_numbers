#!perl
use v5.22.0;
use utf8;

use feature qw(signatures postderef);
no warnings map { "experimental::$_" } qw(signatures postderef);

use FindBin;
use lib "$FindBin::Bin/../lib";

use Data::Dumper;
use ExcellentNumber qw(is_excellent);
use File::Basename qw(basename);
use File::Spec::Functions qw(catfile no_upwards);
use IO::Interactive qw(interactive);
use Set::IntSpan;

my $output_dir = $ARGV[0] // 'output';
opendir my $dh, $output_dir or die "Could not open [$output_dir]: $!\n";

my $hash;

=pod

*** [89849] [1449865800] working on: 572965008746 tried: 3696589318 rate: 4107321 / sec
*** [89849] time left: 0 wk 0 d 3 h 3 m 2 s
+++ [89849] Checked [100000000000] to [576664001452]
*** [89849] [1449866700] working on: 576664001452 tried: 3698992706 rate: 4109991 / sec
*** [89849] time left: 0 wk 0 d 2 h 2 m 47 s
578571099120955675476225 is excellent
579021625716956183909488 is excellent
+++ [89849] Checked [100000000000] to [580365067368]

=cut

my %r = (
	stars         => qr/\A\Q***\E\s*/,
	pluses        => qr/\A\Q+++\E\s*/,
	bangs         => qr/\A\Q!!!\E\s*/,
	pid           => q/\s*\[[0-9]{1,5}\]\s*/,
	);

my %regexes = (
	old_start_end => qr/$r{stars}  (?:$r{pid})? (?<start>[0-9]+) \s* \Q..\E \s* (?<end>[0-9]+) /x,

	start         => qr/$r{stars}  (?:$r{pid})? start \s+ a \s+ is \s+ (?<start>[0-9]+) /x,
	end           => qr/$r{stars}  (?:$r{pid})? end \s+ a \s+ is \s+ (?<end>[0-9]+) /x,

	old_progess   => qr/$r{stars}  (?:$r{pid})? (?:\[.*?])? \s* Working \s+ on :? \s+ (?<progress>[0-9]+) \s+/xi,
	progress      => qr/$r{pluses} (?:$r{pid})? Checked \s+ \[(?<start>[0-9]+)\] \s+ to \s+ \[(?<progress>[0-9]+)\]/xi,
	);

FILE: while( my $output_file = readdir $dh ) {
	next FILE if $output_file =~ /\A\./;
	my $this = $hash->{$output_file} = {};
	my $path = catfile( $output_dir, $output_file );
	next FILE unless -T $path;
#	say {interactive} "Checking on $output_file";

	open my $fh, '<:utf8', $path or do { warn "Could not open file [$path]: $!"; next FILE };

	LINE: while( <$fh> ) {
		if( m/$R{old_start_end}/ ) {
			$this->@{ qw(start end) } = @+{qw(start end)};
		#	say {interactive} "Found start [$+{start}] and end [$+{end}]";
			}
		elsif( m/$R{start}/x ) {
			$this->{ 'start' } = $+{start};
		#	say {interactive} "Found start [$+{start}]";
			}
		elsif( m/$R{end}/x ) {
			$this->{'end'} = $+{end};
		#	say {interactive} "Found end [$+{end}]";
			}
		elsif( m/$R{old_progress}/ or m/$R{progress}/ ) {
			$this->{'progress'} = $+{progress};
		#	say {interactive} "Found progress [$+{progress}]";
			}
		}
	}

#say Dumper( $hash );

my $ranges;
foreach my $file ( keys %$hash ) {
	my $this = $hash->{$file};

	my $length = 2 * length $this->{start};
	my $set_spec = join '-', $this->@{ qw(start progress) };
#	say "$length: $set_spec";
	push $ranges->{$length}->@*, $set_spec;
	}
#say Dumper( $ranges );

foreach my $length ( sort { $a <=> $b } keys %$ranges ) {
	my $set = Set::IntSpan->new( $ranges->{$length}->@* );

	my $holes = $set->holes;
	say "$length: $holes";
	}

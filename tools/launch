#!perl
use v5.22.0;

use feature qw(signatures);
no warnings qw(experimental::signatures);

use Data::Dumper;
use File::Path              qw(make_path);
use File::Spec::Functions   qw(catfile updir);
use Getopt::Long            qw(GetOptions);
use POSIX                   qw(ceil :sys_wait_h);

die "Invalid options or values\n" unless GetOptions( \my %opts,
	'processes|j=i',
	'start=i',
	'end=i',
	'length|l=i',
	'output_dir|o=s',
	'command|cmd=s',
	'sleep|s=i',
  	 );

$opts{'processes'}    //=  1;
$opts{'length'}       //= 10;
$opts{'start'}        //=  1;
$opts{'end'}          //= 62;
$opts{'output_dir'}   //= 'output';
$opts{'command'}      //= catfile( 'c', 'excellent-gmp' );
$opts{'sleep'}        //= 300;

if( $opts{'length'} % 2 ) {
	die "length must be an even number (not  $opts{'length'})\n";
	}

unless( -d $opts{'output_dir'} ) {
	make_path( $opts{'output_dir'} ) or
		die "Output directory $opts{'output_dir'} does not exist!\n";
	}

unless( -e $opts{'command'} ) {
	die "Command $opts{'command'} does not exist!\n";
	}

unless( -x $opts{'command'} ) {
	die "Command $opts{'command'} is not executable!\n";
	}

foreach my $key ( qw( start end ) ) {
	if( length $opts{$key} < $opts{'length'} / 2 ) {
		$opts{$key} .= 0 x ( $opts{'length'} / 2 - length $opts{$key} );
		}
	}

my $interval = ceil(
	( $opts{'end'} - $opts{'start'} ) / $opts{'processes'}
	);

my @output_files = ();
my %children;
for( my $a = $opts{'start'}; $a <= $opts{'end'}; $a += $interval ) {
	state $i = 0;
	$i++;
	my $end = $a + $interval - 1;

	$end = $opts{'end'} if $end > $opts{'end'};

	my @args = ( $opts{'length'}, $a, $end );
	my $output_file = make_filename( $opts{length}, $a, $end );
	push @output_files, $output_file;

	if( my $child_pid = fork ) { # parent
		say "Parent process $$ forked child $child_pid, saving in $output_file";
		$children{$child_pid} = {
			file  => $output_file,
			start => $a,
			end   => $end,
			done  => 0,
			};
		}
	else { # child
		say "Child process $$ with args: @args";
		my $output_file = catfile(
			$opts{'output_dir'}, $output_file,
			);

		open STDOUT, '>:utf8', $output_file
			or die "Could not open $output_file: $!";

		say "$opts{command} $args[0]";
		exec $opts{command}, @args;
		die "Could not exec! $!";
		}
	}

while (1) {
	foreach my $pid ( keys %children ) {
		next if $children{$pid}{done};
		my $rc = waitpid( $pid, WNOHANG );
		$children{$pid}{done} = 1 if $rc == -1;
		if( $rc == $pid ) {
			say "Child $pid is done";
			$children{$pid}{done} = 1
			}
		if( $rc == 0 ) {
			say "Child $pid is still running";
			}
		}

	last if grep { $children{$_}{done} == 0 } keys %children;

	say "Still working. Sleeping for $opts{'sleep'} seconds";

	sleep $opts{'sleep'};
	}

sub make_filename ( $length, $start, $end, $pid=$$, $time=time ) {
	return join( '.', $length, $start, $end, $pid, 'txt' )
	}

say "All done."
